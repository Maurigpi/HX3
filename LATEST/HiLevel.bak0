// #############################################################################
// #############################################################################
// ###                HX3 Engine common Highlevel functions                  ###
// #############################################################################
// #############################################################################


procedure MidiSendPreset(my_channel_offset, my_preset: byte);
begin
  if edit_MIDI_Option <> 0 then
    SendByteToFPGA(($C0+edit_MIDI_Channel+my_channel_offset), $0C);  // Program Change
    SendByteToFPGA(my_preset, $0C);  // Program Change
  endif;
end;

procedure MidiSendController(my_channel_offset, my_ctrl, my_val: byte);
var my_oldval: byte;
begin
  if edit_MIDI_Option <> 0 then
    my_oldval:= gettable(midi_cc_values,my_ctrl); // alter bereits gesendeter Wert
    if my_oldval <> my_val then
      SendByteToFPGA(($B0+edit_MIDI_Channel+my_channel_offset), $0C);  // Control Change
      SendByteToFPGA(my_ctrl, $0C);  // Control Change
      SendByteToFPGA(my_val, $0C);  // Control Change
      settable(midi_cc_values,my_ctrl, my_val);
    endif;
  endif;
end;

procedure MidiSendTab(my_ctrl: byte; my_bool: boolean);
begin
  MidiSendController(0, my_ctrl, byte(my_bool) shr 1);
end;


procedure MemLED(my_memled:boolean); forward;

// #############################################################################
// ###             Tabs und gesetzte Parameter an FPGA senden                ###
// #############################################################################

procedure VibratoToFPGA;
// Vibrato zusammengesetzt aus Upper und Lower*2 ans FPGA
// SPI-Registerwerte 74..79 (64..73 ist Volume-Port)

var  my_byte: byte;
begin
  my_byte:= 0;
  if Tab_VibOnUpper then
    inc(my_byte);
  endif;
  if Tab_VibOnLower then
    inc(my_byte);
    inc(my_byte);
  endif;
  SendByteToFPGA(my_byte, 78);  // VibrSelect Off/U/L/beide
  case edit_Upper_VibKnob of
    0, 2, 4 :  // Vibrato
      SendByteToFPGA(255, 75);       // VibLevel auf Max
      SendByteToFPGA(0, 76);         // DryLevel ganz aus
      |
    1, 3, 5 :  // Chorus
      SendByteToFPGA(edit_ChVibMix, 75); // VibLevel Chorus Mix
      SendByteToFPGA(edit_ChDryMix, 76); // DryLevel Chorus Mix
      |
  endcase;
  case edit_Upper_VibKnob of
    0, 1 :  // Stufe 1
      SendByteToFPGA(edit_Vib1_Age, 77); // Age 1
      SendByteToFPGA(edit_Vib1_FM, 74); // VibDepth 1
      |
    2, 3 :  // Stufe 2
      SendByteToFPGA(edit_Vib2_Age, 77); // Age 2
      SendByteToFPGA(edit_Vib2_FM, 74); // VibDepth 2
      |
    4, 5 :  // Stufe 3
      SendByteToFPGA(edit_Vib3_Age, 77); // Age 3
      SendByteToFPGA(edit_Vib3_FM, 74); // VibDepth 3
      |
  endcase;
end;

procedure UpperToFPGA;
// Vorbereitete Parameter-Tabelle UPPER und Tab_Bits an FPGA
var my_idx, my_offs, my_byte: byte; my_mute_db: boolean;
begin
// allgemeine Parameter, immer übertragen
// 8 skalierte Drawbar-Werte Upper an FPGA, ohne 1'
  my_mute_db:= Tab_PercOn and (not Tab_PercSoft);
  for i:= 0 to 7 do
    my_byte:= edit_upper_db_arr[i];
    MidiSendController(0, i+12, my_byte);
    if my_mute_db then
      my_byte:= my_byte shr 1; // Pegel -6dB
    endif;
    SendByteToFPGA(my_byte, i+16);
  endfor;
  MidiSendController(0, 20, edit_UpperDB_1); // 1'
// Percussion ans FPGA, sofern nicht A# LIVE Preset (15) zweiter Zugriegelsatz
  if Tab_PercOn and (not DisablePercussion) then
    if edit_NoDB1_atPerc then
      SendByteToFPGA(0, 24);  // 1' aus
    else
      if my_mute_db then
        my_byte:= edit_UpperDB_1 shr 1;  // 1' Drawbar
      else
        my_byte:= edit_UpperDB_1;  // 1' Drawbar
      endif;
      SendByteToFPGA(my_byte, 24);
    endif;
    if Tab_Perc3rd then
      SendByteToFPGA(1, 27); // Perc Select 3rd an
    else
      SendByteToFPGA(0, 27); // Perc Select 2nd an
    endif;
    if Tab_PercSoft then
      SendByteToFPGA(edit_PercSoftLvl, 26);
    else
      SendByteToFPGA(edit_PercNormLvl, 26);
    endif;
    if Tab_PercFast then
      SendByteToFPGA(edit_PercShortTm, 25); // alte Adresse
    else
      SendByteToFPGA(edit_PercLongTm, 25); // alte Adresse
    endif;
  else
    my_byte:= edit_UpperDB_1;  // 1' Drawbar
    SendByteToFPGA(my_byte, 24);
    SendByteToFPGA(0, 26); // Perc Level ganz aus, Rest egal
  endif;
end;

procedure LowerToFPGA;
// Vorbereitete Parameter-Tabelle LOWER für HX3-Engine an FPGA
var  my_byte: byte;
begin
// 9 skalierte Drawbar-Werte Lower an FPGA
  for i:= 0 to 8 do // Lower Drawbars
    my_byte:= edit_lower_db_arr[i];
    SendByteToFPGA(my_byte, i + 32);
    MidiSendController(0, i+21, my_byte);
  endfor;
end;


procedure BassSplitToFPGA;
// Vorbereitete Parameter-Tabelle BASS für HX3-Engine an FPGA
var my_byte: byte;
begin
// Pedal-Bass-Drawbar ans FPGA
  MidiSendController(0, 33, edit_PedalDB_16);
  MidiSendController(0, 34, edit_PedalDB_5_13);
  MidiSendController(0, 35, edit_PedalDB_8);
  
  my_byte:=  edit_PedalDB_16 shr 1;
  SendByteToFPGA(edit_PedalDB_16 + my_byte, 41); // aus Tabelle DB 16
  my_byte:=  edit_PedalDB_5_13 shr 1;
  SendByteToFPGA(edit_PedalDB_5_13 + my_byte, 42);  // aus Tabelle DB 5 1/3
  my_byte:=  edit_PedalDB_8 shr 1;
  SendByteToFPGA(edit_PedalDB_8 + my_byte, 43);  // aus Tabelle DB 8
// Sustainwert-Berechnung
// Poti-Wert in Timer-Wert umrechnen per Antilog-Tabelle
  MidiSendController(0, 75, edit_PedalSustain shr 1);
  my_byte:= gettable(AntilogTable,edit_PedalSustain shr 1); // 0..127 -> 0..63 -> Kehrwert
  SendByteToFPGA(my_byte, 15); // aus Tabelle, jetzt PB-Timer
// Bass To Leslie
  SendByteToFPGA(edit_SplitOption, 6);    // Scan/Split Option
  SendByteToFPGA(byte(Tab_SplitOn) and 1, 7);    // Scan/Split On/Off
  if Tab_Bassena then
    my_byte:= edit_OutpConfigB;  // Alternative Konfiguration
  else
    my_byte:= edit_OutpConfigA;
  endif;
  SendByteToFPGA(my_byte, 179);    // I2S Output Jack Config

end;

// -----------------------------------------------------------------------------

procedure ReverbToFPGA;
// Vorbereitete Parameter-Tabelle UPPER für HX3-Engine an FPGA
var my_byte: byte;
begin
// Parameter für Spin FV-1 Effekt
  my_byte:= (edit_ReverbPrg and 3) or 8; // nur vier Programme zulässig
  SendByteToFPGA(my_byte, 72); // FV-1 PRG im Volume-Port-Bereich
  my_byte:= (edit_ReverbPrg and 3) shl 3;
  SendByteToFPGA(160+my_byte, 69); // PWM 0
  
  if edit_ReverbPrg = 0 then
    SendByteToFPGA(0, 70); // FV-1 PWM 1 im Volume-Port-Bereich
    SendByteToFPGA(0, 71); // FV-1 PWM 2 im Volume-Port-Bereich
  else
    my_byte := edit_reverb_arr[edit_ReverbPrg-1];
    SendByteToFPGA(my_byte, 70); // PWM 1
    SendByteToFPGA(my_byte, 71); // PWM 2
  endif;
  EfxChangedFlag := false;
end;

// -----------------------------------------------------------------------------

procedure OrganInitToFPGA;
// Edit-Tabelle Orgel an FPGA
var my_byte: byte;
// nur übertragen, wenn im Menü geändert
begin
  SendByteToFPGA(edit_DB16_FoldbMode, 10); // Foldback 16'
  SendByteToFPGA(edit_MIDI_Channel, 4); // MIDI-Channel
  SendByteToFPGA(edit_MIDI_Option, 5); // MIDI-Option
  SendByteToFPGA(edit_SplitOption, 6);    // Scan/Split Option
  
  my_byte:= (edit_ContSpringFlx shl 4) or (edit_ContSpringDmp and 15);
  SendByteToFPGA(my_byte, 9); // Klick-Länge und Noise-Frequenz, war KEY_OFFS
  
  my_Byte:= (edit_TG_Flutter) or ((byte(edit_TG_OldCaps) and 1) shl 5) or (edit_TG_Leakage shl 6);
  SendByteToFPGA(my_byte, 11); // Flutter/Leakage
  SendByteToFPGA(edit_Transpose, 13);    // positive Werte verschieben Töne nach UNTEN!
  SendByteToFPGA(edit_Triode_k2, 73);
  SendByteToFPGA(200, 79);  // BypassLevel, leicht Absenkung für Nicht-Vibrato-Kanal
{$IFDEF DEBUGTEST}
  write(serout, '# Send Param Defaults');
  SerCRLF;
{$ENDIF}
  DefaultsChangedFlag:=false;
end;

// -----------------------------------------------------------------------------

// #############################################################################
// ###   Geänderte Analogwerte in Parameter übertragen und an FPGA           ###
// ###   User-Interface-spezifisch, abhängig von Anzahl Zugriegel!           ###
// #############################################################################

{$IFDEF SINGLE_DRAWBARS}
// zum Beispiel XB2 mit nur einem Zugriegelsatz an LOWER!!!

// User-Interface-spezifisch, abhängig von Anzahl Zugriegel!
// Bei Änderungen an Drawbars und Potis hat ADC-Routine Flags zu den jeweiligen
// Rohdaten (24 Kanäle fortlaufend in adc_table) gesetzt. Diese werden hier in
// ParamTable für evt. späteres Abspeichern übertragen und das zugehörige Flag
// gelöscht.
// Die Werte in ParamTable werden falls notwendig an das PGA gesendet.

procedure AnalogUpperUpdate(my_updforce: boolean);
// SINGLE_DRAWBARS,zum Beispiel XB2 mit nur einem Zugriegelsatz an LOWER!!!
// Analogwerte bei Änderungen in ParamTable pt_* übertragen
// Die geänderten Werte werden zum FPGA gesendet.
var my_byte: byte; my_bool, my_update: boolean;
begin
// Upper Drawbars
  if ManualSelect<>0 then  // nur wenn Upper
    return;
  endif;
  my_update:= false;
  for i:= 0 to 8 do         // 9 Zugriegel-Analogwerte "live" übernehmen
    if my_updforce or gettable(LowerDrawbarsADCchanged, i)  then
      my_byte:= gettable(LowerDrawbarsADC, i) shr 1; // ADC-Wert 0..255 auf 0..127
      edit_upper_db_arr[i] := my_byte;
      settable(LowerDrawbarsADCchanged, i, false);
      my_update:= true;
      if not my_updforce then
        DisplayMenuRequest:= 13;
      endif;
{$IFDEF DEBUGTEST}
      write(serout, '# Upper Drawbar: ');
      write(serout, ByteToStr(i));
      write(serout, ' Analog:');
      WriteByte(my_Byte);
{$ENDIF}
    endif;
  endfor;
  if my_update then
    UpperToFPGA;
  endif;
end;

procedure AnalogLowerUpdate(my_updforce: boolean);
// SINGLE_DRAWBARS,zum Beispiel XB2 mit nur einem Zugriegelsatz an LOWER!!!
// Analogwerte bei Änderungen in ParamTable pt_* übertragen
// Die geänderten Werte werden zum FPGA gesendet.
var my_byte: byte; my_bool, my_update: boolean;
begin
// Upper Drawbars
  if ManualSelect<>1 then  // nur wenn Lower
    return;
  endif;
  my_update:= false;
  for i:= 0 to 8 do         // 9 Zugriegel-Analogwerte "live" übernehmen
    if my_updforce or gettable(LowerDrawbarsADCchanged, i)  then
      my_byte:= gettable(LowerDrawbarsADC, i) shr 1; // ADC-Wert 0..255 auf 0..127
      edit_lower_db_arr[i] := my_byte;
      settable(LowerDrawbarsADCchanged, i, false);
      my_update:= true;
      if not my_updforce then
        DisplayMenuRequest:= 14;
      endif;
{$IFDEF DEBUGTEST}
      write(serout, '# Lower Drawbar: ');
      write(serout, ByteToStr(i));
      write(serout, ' Analog:');
      WriteByte(my_Byte);
{$ENDIF}
    endif;
  endfor;
  if my_update then
    LowerToFPGA;
  endif;
end;


procedure AnalogBassUpdate(my_updforce: boolean);
// SINGLE_DRAWBARS,zum Beispiel XB2 mit nur einem Zugriegelsatz an LOWER!!!
// Pedal-Drawbars
// Analogwerte bei Änderungen in ParamTable pt_* übertragen
// Die geänderten Werte werden zum FPGA gesendet.
var my_byte: byte; my_update: boolean;
begin
  if ManualSelect<>2 then  // nur wenn Pedal
    return;
  endif;
  my_update:= false;
  for i:= 0 to 3 do         // 3 Zugriegel-Analogwerte "live" übernehmen
    if my_updforce or gettable(LowerDrawbarsADCchanged, i)  then
      my_byte:= gettable(LowerDrawbarsADC, i) shr 1; // ADC-Wert 0..255 auf 0..127
      edit_pedal_db_arr[i] := my_byte;
      settable(LowerDrawbarsADCchanged, i, false);
      my_update:= true;
      if not my_updforce then
        DisplayMenuRequest:= 14;
      endif;
{$IFDEF DEBUGTEST}
      write(serout, '# Bass Drawbar: ');
      write(serout, ByteToStr(i));
      write(serout, ' Analog:');
      WriteByte(my_Byte);
{$ENDIF}
    endif;
  endfor;
  if my_update then
    BassSplitToFPGA;
  endif;
end;

{$IFDEF XB2}
procedure WheelToMIDI;
// XB2 mit Modwheel an Analog 22 (Lower Pin 11) und Pitchwheel an Analog 23 (Lower Pin 12)
// Die geänderten Werte werden zum FPGA gesendet.
var my_byte: byte;
begin
{$IFDEF HX3mk3}
  if XB2_ModWheelADCchanged  then
    my_byte:= XB2_ModWheelADC shr 1; // ModWheel
    // hier zu Fuß, um MIDI-Send-Flags von Controller 1 nicht zu ändern
    SendByteToFPGA(($B0+edit_MIDI_Channel), $0C);
    SendByteToFPGA(1, $0C);        // SPI MIDI send
    SendByteToFPGA(my_byte, $0C);
    XB2_ModWheelADCchanged:= false;
    XB2_ModWheelADChyst:= c_coarse_ADChyst;
  endif;
// Mittelstellung bei XB2 ist etwa $39 = 57
  if XB2_PitchWheelADCchanged  then
    my_byte:= XB2_PitchWheelADC shr 1; // Pitchwheel
    if valueinrange(my_byte,XB2_PitchWheelMid - c_coarse_ADChyst, XB2_PitchWheelMid + c_coarse_ADChyst) then
      my_byte:= $40; // Mittelstellung
    else
      if my_byte > XB2_PitchWheelMid then
        my_byte:= ($40 - c_coarse_ADChyst) + my_byte - XB2_PitchWheelMid; // ermittelter Offset
      else
        my_byte:= ($40 + c_coarse_ADChyst) + my_byte - XB2_PitchWheelMid; // ermittelter Offset
      endif;
    endif;
    my_byte:= valuetrimlimit(my_byte,0,$7F); // begrenzen
    SendByteToFPGA(($E0+edit_MIDI_Channel), $0C);
    SendByteToFPGA(0, $0C);        // SPI MIDI send
    SendByteToFPGA(my_byte, $0C);
    XB2_PitchWheelADCchanged:= false;
    XB2_PitchWheelADChyst:= c_coarse_ADChyst;
  endif;
{$ENDIF}
end;
{$ENDIF}

{$ELSE} // Standard, keine SINGLE_DRAWBARS

// #############################################################################
// ###   Geänderte Analogwerte in Parameter übertragen und an FPGA           ###
// #############################################################################

// User-Interface-spezifisch, abhängig von Anzahl Zugriegel!
// Bei Änderungen an Drawbars und Potis hat ADC-Routine Flags zu den jeweiligen
// Rohdaten (24 Kanäle fortlaufend in adc_table) gesetzt. Diese werden hier in
// ParamTable für evt. späteres Abspeichern übertragen und das zugehörige Flag
// gelöscht.
// Die Werte in ParamTable werden falls notwendig an das PGA gesendet.

procedure AnalogUpperUpdate(my_updforce: boolean);
// Analogwerte bei Änderungen in ParamTable pt_* übertragen
// Die geänderten Werte werden zum FPGA gesendet.
var my_byte: byte; my_update: boolean;
begin
// Upper Drawbars
  my_update:= false;
  for i:= 0 to 8 do         // 9 Zugriegel-Analogwerte "live" übernehmen
    if my_updforce or gettable(UpperDrawbarsADCchanged, i) then
      my_byte:= gettable(UpperDrawbarsADC, i) shr 1; // ADC-Wert 0..255 auf 0..127
      // MIDI-Daten nach NI B4-Belegung senden
      edit_upper_db_arr[i] := my_byte;
      settable(UpperDrawbarsADCchanged, i, false);
      my_update:= true;
      if not my_updforce then
        DisplayMenuRequest:= 13;
      endif;
{$IFDEF DEBUGTEST}
      write(serout, '# Upper Drawbar: ');
      write(serout, ByteToStr(i));
      write(serout, ' Analog:');
      WriteByte(my_Byte);
{$ENDIF}
    endif;
  endfor;
  if my_update then
    UpperToFPGA;
  endif;
end;


procedure AnalogLowerUpdate(my_updforce: boolean);
// Lower Drawbars
// Analogwerte bei Änderungen in ParamTable pt_* übertragen
// Die geänderten Werte werden zum FPGA gesendet.
var my_byte: byte; my_update: boolean;
begin
  my_update:= false;
  for i:= 0 to 8 do // 9 Zugriegel-Analogwerte Lower live übernehmen
    if my_updforce or gettable(LowerDrawbarsADCchanged, i) then
      my_byte:= gettable(LowerDrawbarsADC, i) shr 1; // ADC-Wert 0..255 auf 0..127
      // MIDI-Daten nach NI B4-Belegung senden
      edit_lower_db_arr[i]:= my_byte;
      settable(LowerDrawbarsADCchanged, i, false);
      my_update:= true;
      if not my_updforce then
        DisplayMenuRequest:= 14;
      endif;
{$IFDEF DEBUGTEST}
      write(serout, '# Lower Drawbar: ');
      write(serout, ByteToStr(i));
      write(serout, ' Analog:');
      WriteByte(my_Byte);
{$ENDIF}
    endif;
  endfor;
  if my_update then
    LowerToFPGA;
  endif;
end;


procedure AnalogBassUpdate(my_updforce: boolean);
// Pedal-Drawbars
// Analogwerte bei Änderungen in ParamTable pt_* übertragen
// Die geänderten Werte werden zum FPGA gesendet.
var my_byte: byte; my_update: boolean;
begin
  if my_updforce or Bass16ADCchanged then
    edit_PedalDB_16:= Bass16ADC shr 1;  // Bass-DB 16
    edit_PedalDB_5_13:= edit_PedalDB_16 shr 1; // 5 1/3' halber Wert von 16'
    Bass16ADCchanged:= false;
    BassSplitToFPGA;
{$IFDEF DEBUGTEST}
    write(serout, '# Bass Drawbar: 0 Analog:');
    WriteByte(edit_PedalDB_16);
{$ENDIF}
    DisplayMenuRequest:= 14;
  endif;
  if my_updforce or Bass8ADCchanged then
    edit_PedalDB_8:= Bass8ADC shr 1;  // Bass-DB 8
    Bass8ADCchanged:= false;
    BassSplitToFPGA;
{$IFDEF DEBUGTEST}
    write(serout, '# Bass Drawbar: 1 Analog:');
    WriteByte(edit_PedalDB_8);
{$ENDIF}
    DisplayMenuRequest:= 14;
  endif;
  if my_updforce or BassSustainADCchanged then
    edit_PedalSustain:= BassSustainADC shr 1;
    BassSustainADCchanged:= false;
    BassSplitToFPGA;
{$IFDEF DEBUGTEST}
    write(serout, '# BassSustain Analog:');
    WriteByte(edit_PedalSustain);
{$ENDIF}
    DisplayMenuRequest:= 28;
  endif;
end;

{$ENDIF} // SINGLE_DRAWBARS


// #############################################################################
// ###                   Tabs auswerten und Änderungen an FPGA               ###
// #############################################################################

procedure KnobChangeToFPGA;
// Drehschalter, hier nur Vibrato
var my_byte: byte;
begin
  if KnobChange_Vibrato then
{$IFDEF DEBUGTEST}
    write(serout, '# KnobChange Vibrato:');
    WriteByte(edit_Upper_VibKnob);
{$ENDIF}
    KnobChange_Vibrato:= false;
    DisplayMenuRequest:= 10;
    ToneADCchanged:= true;
  // 73, Vibrato Mix; $3F = Chorus, $7F = Vibrato
  // 74, Vibrato Amount
    my_byte:= ((edit_Upper_VibKnob shr 1) * 48) + 31;
    MidiSendController(0, 74, my_byte);
    if (edit_Upper_VibKnob and 1) = 1 then
      MidiSendController(0, 73, $3F); // Chorus
    else
      MidiSendController(0, 73, $7F); // Vibrato
    endif;
  endif;
  VibratoToFPGA;
end;


procedure TabChangeToFPGA;
// Routinen für Switch-Auswertung:
// Chores oder MIDI-CC haben Schalter- und Button-Stellungen aktualisiert und in
// Tab_Bits1 und Tab_Bits2 abgelegt.
// Bei *geänderter* Schalter- oder Button-Stellung sind
// die korrespondieren Bits in TabChange_Bits1 und TabChange_Bits2 gesetzt.
// Nach Behandlung werden sie hier zurückgesetzt.
// Die geschriebenen Werte werden gleich zum FPGA gesendet!

var my_byte: byte; my_bool, my_update: boolean;
begin
{$IFDEF DEBUGTEST}
  if TabChange_Bits1 <> 0 then
    write(serout, '# Tab Bits1:');
    WriteByte(Tab_Bits1);
  endif;
  if TabChange_Bits2 <> 0 then
    write(serout, '# Tab Bits2:');
    WriteByte(Tab_Bits2);
  endif;
{$ENDIF}

  if ((TabChange_Bits1 or TabChange_Bits2) = 0) then
    return; // nichts weiter zu tun
  endif;

  if TabChange_PercOn then
    UpperToFPGA;
    {$IFDEF DEBUGTEST}
    write(serout, '# Perc ON:');
    WriteBool(Tab_PercOn);
    {$ENDIF}
    DisplayMenuRequest:= 12;
    MidiSendTab(66, Tab_PercOn);
  endif;
  if TabChange_PercSoft then
    UpperToFPGA;
    {$IFDEF DEBUGTEST}
    write(serout, '# Perc SOFT:');
    WriteBool(Tab_PercSoft);
    {$ENDIF}
    DisplayMenuRequest:= 12;
    MidiSendTab(70, Tab_PercSoft);
  endif;
  if TabChange_PercFast then
    UpperToFPGA;
    {$IFDEF DEBUGTEST}
    write(serout, '# Perc FAST:');
    WriteBool(Tab_PercFast);
    {$ENDIF}
    DisplayMenuRequest:= 12;
    MidiSendTab(71, Tab_PercFast);
  endif;
  if TabChange_Perc3rd then
    UpperToFPGA;
    {$IFDEF DEBUGTEST}
    write(serout, '# Perc 3RD:');
    WriteBool(Tab_Perc3rd);
    {$ENDIF}
    DisplayMenuRequest:= 12;
    MidiSendTab(72, Tab_Perc3rd);
  endif;

  if TabChange_VibOnUpper then
    VibratoToFPGA;
    {$IFDEF DEBUGTEST}
    write(serout, '# Vib Upper ON:');
    WriteBool(Tab_VibOnUpper);
    {$ENDIF}
    ToneADCchanged:= true; // Volume-Update erzwingen
    DisplayMenuRequest:= 11;
    MidiSendTab(31, Tab_VibOnUpper);
  endif;
  
  if TabChange_VibOnLower then
    VibratoToFPGA;
    {$IFDEF DEBUGTEST}
    write(serout, '# Vib Lower ON:');
    WriteBool(Tab_VibOnLower);
    {$ENDIF}
    ToneADCchanged:= true; // Volume-Update erzwingen
    DisplayMenuRequest:= 15;
    MidiSendTab(30, Tab_VibOnLower);
  endif;

  if TabChange_effect1 or TabChange_effect2 or EfxChangedFlag then
    edit_ReverbPrg:= 0;
    if Tab_effect1 then
      inc(edit_ReverbPrg);
    endif;
    if Tab_effect2 then
      edit_ReverbPrg:= edit_ReverbPrg + 2;
    endif;
    ReverbToFPGA;
    {$IFDEF DEBUGTEST}
    write(serout, '# Efx/Reverb Pgm:');
    WriteByte(edit_ReverbPrg);
    {$ENDIF}
    DisplayMenuRequest:= 32;
  endif;

  if TabChange_bassena then
    edit_JackConfig:= Tab_bassena;
    BassSplitToFPGA;
    {$IFDEF DEBUGTEST}
    write(serout, '# Bass To Leslie:');
    WriteBool(Tab_bassena);
    {$ENDIF}
    DisplayMenuRequest:= 29;
  endif;

  if TabChange_SplitLower then
    edit_KeyboardSplit:= Tab_SplitOn;
    BassSplitToFPGA;
    {$IFDEF DEBUGTEST}
    write(serout, '# Split On:');
    WriteBool(Tab_SplitOn);
    {$ENDIF}
    DisplayMenuRequest:= 30;
  endif;

//  if TabChange_LeslieRun or TabChange_Lesliefast then
// Werden ansonsten von SendLeslie und Chores behandelt
//  endif;

// alle behandelt, wieder zurücksetzen
  TabChange_Bits1:= 0;
  TabChange_Bits2:= 0;
end;


// #############################################################################
// ###       Temp/EEPROM-Routinen SAVE und LOAD Presets, Defaults            ###
// #############################################################################

procedure UpperFromTemp;
var my_byte: byte;
begin
  for i:= 0 to 9 do  // inkl. Vibrato-Stellung
// 9 Zugriegel-Analogwerte und Vibrato-Knopf aus Temp-Array übernehmen
    my_byte := gettable(temp_UpperTable,i);
    edit_upper_db_arr[i]:=  my_byte;
// Preset geändert, jetzt wieder niedrige Empfindlichkeit -- zufällig auch 10 Werte
    settable(UpperDrawbarsADChyst, i, c_midi_ADChyst);
  endfor;
  Tab_Bits1 := (Tab_Bits1 and %11100000) or temp_UpperTabBits1; // Percussion, Vibrato On Bit
  TabChange_Bits1:= %00011111;
  {$IFDEF DEBUGTEST}
  write(serout, '#### Upper From Temp');
  SerCRLF;
  {$ENDIF}
end;

procedure UpperToTemp;
var my_byte: byte;
begin
  for i:= 0 to 9 do  // inkl. Vibrato-Stellung
    my_byte := edit_upper_db_arr[i];
    settable(temp_UpperTable, i, my_byte);
  endfor;
  temp_UpperTabBits1:= Tab_Bits1 and %00011111; // Percussion, Vibrato On Bit
  {$IFDEF DEBUGTEST}
  write(serout, '#### Upper To Temp');
  SerCRLF;
  {$ENDIF}
  MEMled(false);
end;

procedure LowerFromTemp;
var my_byte: byte;
begin
  for i:= 0 to 12 do
// 9 Zugriegel-Analogwerte Pedal aus Temp-Array übernehmen
    my_byte := gettable(temp_LowerTable,i);
    edit_lower_db_arr[i]:=  my_byte;
// Preset geändert, jetzt wieder niedrige Empfindlichkeit -- zufällig auch 10 Werte
    settable(LowerDrawbarsADChyst, i, c_midi_ADChyst);
  endfor;
  Tab_Bits1 := (Tab_Bits1 and %11011111) or temp_LowerTabBits1; // Vibrato On Bit
  TabChange_Bits1:= %00100000;
//  Tab_Bits2 := (Tab_Bits2 and %00111111) or temp_LowerTabBits2; // Split, Bass On Leslie
//  TabChange_Bits2:= %11000000;
  {$IFDEF DEBUGTEST}
  write(serout, '#### Lower From Temp');
  SerCRLF;
  {$ENDIF}
end;

procedure LowerToTemp;
var my_byte: byte;
begin
  for i:= 0 to 12 do  // inkl. Bass etc.
    my_byte := edit_lower_db_arr[i];
    settable(temp_LowerTable, i, my_byte);
  endfor;
  temp_LowerTabBits1:= Tab_Bits1 and %00100000;      // Vibrato On Bit überschreiben
//  temp_LowerTabBits2:= Tab_Bits2 and %11000000;      // Bass/Split-bits überschreiben
  {$IFDEF DEBUGTEST}
  write(serout, '#### Lower To Temp');
  SerCRLF;
  {$ENDIF}
end;

// #############################################################################

procedure LoadUpper(index:byte);
begin
  MEMled(true);
  for i:= 0 to 8 do
// 9 Zugriegel-Analogwerte aus EEupperArray übernehmen
    edit_upper_db_arr[i]:= EEupperArray[index, i];
// Preset geändert, jetzt wieder niedrige Empfindlichkeit -- zufällig auch 10 Werte
    settable(UpperDrawbarsADChyst, i, c_midi_ADChyst);
  endfor;
// Vibrato-Knopf aus EEupperArray übernehmen
  edit_Upper_VibKnob:= EEupperArray[index, 9];
  Tab_Bits1 := (Tab_Bits1 and %11100000) or (EEupperArray[index, 10] and %00011111); // Percussion, Vibrato On Bit
  TabChange_Bits1:= %00011111;
  mdelay(10);
  {$IFDEF DEBUGTEST}
  write(serout, '#### Upper Load Preset:');
  WriteByte(index);
  {$ENDIF}
  MEMled(false);
end;

procedure SaveUpper(index:byte);
begin
  MEMled(true);
  index:= index and 15;
  for i:= 0 to 9 do  // inkl. Vibrato-Stellung
    EEUpperArray[index, i]:= edit_upper_db_arr[i];
  endfor;
  EEupperArray[index, 10]:= Tab_Bits1 and %00011111; // Percussion, Vibrato On Bit
  {$IFDEF DEBUGTEST}
  write(serout, '#### Upper Save Preset:');
  WriteByte(index);
  {$ENDIF}
  MEMled(false);
  DisplayMsgPause;               // weitere Anzeigen unterbinden
  DisplayMenuRequest:=13;
end;

procedure LoadLower(index:byte);
// Lower und Pedal Drawbars, VibOn Lower und SplitOn aus EEPROM holen
begin
  MEMled(true);
  for i:= 0 to 12 do
// 9+3 Zugriegel-Analogwerte und Bass aus EELowerArray übernehmen
    edit_lower_db_arr[i]:= EElowerArray[index, i];
    // Preset geändert, jetzt wieder niedrige Empfindlichkeit
    settable(LowerDrawbarsADChyst, i, c_midi_ADChyst);
  endfor;
  Tab_Bits1 := (Tab_Bits1 and %11011111) or (EELowerArray[index, 13] and %00100000); // Vibrato On Bit
  TabChange_Bits1:= %00100000;
//  Tab_Bits2 := (Tab_Bits2 and %00111111) or EELowerArray[index, 14]; // Split, Bass On Leslie
//  TabChange_Bits2:= %11000000;
  mdelay(10);
  {$IFDEF DEBUGTEST}
  write(serout, '#### Lower Load Preset:');
  WriteByte(index);
  {$ENDIF}
  MEMled(false);
end;

procedure SaveLower(index:byte);
begin
  MEMled(true);
  index:= index and 15;
  for i:= 0 to 12 do
    EELowerArray[index, i] := edit_lower_db_arr[i];
  endfor;
  EElowerArray[index, 13]:= Tab_Bits1 and %00100000;      // Vibrato On Bit überschreiben
//  EElowerArray[index, 14]:= Tab_Bits2 and %11000000;      // Bass/Split-bits überschreiben
  {$IFDEF DEBUGTEST}
  write(serout, '#### Lower Save Preset:');
  WriteByte(index);
  {$ENDIF}
  MEMled(false);
  DisplayMsgPause;               // weitere Anzeigen unterbinden
  DisplayMenuRequest:=14;
end;

procedure LoadDefaults;
begin
// restliche Default-Parameter
  for i:= 0 to c_edit_ParamArrLen do
    edit_ParamArr[i]:= EE_Organ_Init[i]; // Param-Array updaten
  endfor;
{$IFDEF DEBUGTEST}
  write(serout, '#### Load Param Defaults');
  SerCRLF;
{$ENDIF}
  for i:= 0 to 15 do
// temp-Arrays vorbelegen
    settable(temp_UpperTable,i,EEupperArray[0, i]);
    settable(temp_LowerTable,i,EElowerArray[0, i]);
  endfor;
  if (edit_ReverbPrg and 1) = 1 then   // aus Defaults!
    Tab_effect1:= true;
  endif;
  if (edit_ReverbPrg and 2) = 2 then
    Tab_effect2:= true;
  endif;
  Tab_bassena:= edit_JackConfig;
  Tab_SplitOn:= edit_KeyboardSplit;

  midi_edit_perc_levelsoft:= edit_PercSoftLvl;
  midi_edit_perc_levelnorm:= edit_PercNormLvl;
  Knob_Bits:= $FF;
  midi_volume128:= 127;
  SwellPedalVal := 200;  // wenn disabled, fester Wert
end;


procedure LeslieInitToFPGA;
var my_word: word; my_long: LongInt; my_byte:Byte;
begin
// Reload FIR Koeffizienten Horn, gleich an FPGA
  SendByteToFPGA(0,247); // Load Enable Trigger
  for my_word := 0 to 511 do
    my_Long:= LongInt(EE_FIRcoef[my_word]);
    SendLongToFPGA(my_Long,246); // Reload FIR
  endfor;
  
// Leslie Equalizer, Offsets und Delays, gleich an FPGA
  for i:=0 to 63 do
    my_byte:= EE_Leslie_Init[i]; // Grundeinstellungen direkt an FPGA
    SendByteToFPGA(my_byte, i+176);
  endfor;
  
{$IFDEF DEBUGTEST}
  write(serout, '#### Load Leslie Defaults');
  SerCRLF;
{$ENDIF}
end;


// #############################################################################
// ###                       Volume an FPGA senden                           ###
// #############################################################################

procedure VolumeToFPGA;
// wird in Mainloop ständig aufgerufen
// Rechnet Byte "volume" in EQ-Paramater um
var my_midrange, my_lowestrange, my_lowrange, my_hirange,
    my_volume_half, my_volume_quarter,
    my_pedal, my_tonepot: byte;
    my_byte, my_dest_hornspeed, my_dest_rotorspeed: Byte;
    my_is_chorus, my_vib_on: boolean;
    my_swell: byte;
begin
  if SwellPedalADCchanged then
    SwellPedalControlledByMIDI:= false;    // Implikation!
  endif;
  if MIDIvolumeChanged then
    SwellPedalControlledByMIDI:= true;     // Implikation!
  endif;
  
  if SwellPedalControlledByMIDI then
    my_swell:= midi_volume128 + midi_volume128_old;
    midi_volume128_old := midi_volume128;  // Integrator
    SwellPedalChanged:= MIDIvolumeChanged;
  else
    SwellPedalChanged:= SwellPedalADC <> lo(SwellPedalValOld);
    SwellPedalVal:= (Integer(SwellPedalADC) + SwellPedalValOld) div 2;
    SwellPedalValOld:= Integer(SwellPedalADC);
    my_swell:= lo(SwellPedalVal);
    MidiSendController(0, 11, my_swell shr 1);
  endif;

  if SwellPedalChanged or ToneADCchanged then

    {$IFDEF DEBUGTEST}
    if MIDIvolumeChanged or SwellPedalChanged then
      write(serout, '# Swell change:');
      WriteByte(SwellPedalVal);
    endif;
    {$ENDIF}
    my_is_chorus:= edit_Upper_VibKnob in [1,3,5];
    my_vib_on:= Tab_VibOnUpper or Tab_VibOnLower;
    

    my_volume_half:= my_swell shr 1;  // 0..127
    my_volume_quarter:= my_volume_half shr 1;   // 0..54

    if edit_TonePotEna then
      my_tonepot := ToneADC shr 1; // 0..127
    else
      my_tonepot:= edit_TrebleEqu; // 0..100
    endif;


    my_lowestrange:= (edit_BassEqu shr 2) +  MulDivByte(my_swell, edit_BassEqu, 190);
    my_lowrange:= (edit_BassEqu shr 3) + MulDivByte(my_swell, edit_BassEqu, 230);
    
    if my_is_chorus then
      my_hirange:=  (my_tonepot shr 3) + MulDivByte(my_swell, my_tonepot, 160);
    else
      my_hirange:=  (my_tonepot shr 3) + MulDivByte(my_swell, my_tonepot, 190);
    endif;
    
    if my_is_chorus then
      my_midrange:= MulDivByte(my_swell, 200, 255) +1;
    else
      my_midrange:= MulDivByte(my_swell, 180, 255) +1;
    endif;

    SendByteToFPGA(190, 79);  // BypassLevel, leichte Absenkung für Nicht-Vibrato-Kanal

    my_pedal:= 64 + my_volume_half + my_volume_quarter;

    SendByteToFPGA(my_midrange, 64);     // Midrange 0 bis 510 Hz
    SendByteToFPGA(my_lowestrange, 65);  // Lowpass 0 bis 63 Hz
    SendByteToFPGA(my_lowrange, 66);     // Lowpass 0 bis 125 Hz
    SendByteToFPGA(my_hirange, 67);      // volle Bandbreite (Treble!)
    SendByteToFPGA(my_pedal, 68);        // Bass Volume

    ToneADCchanged:= false;
    SwellPedalChanged:= false;
    MIDIvolumeChanged:= false; // MIDI-Volume-Flag löschen
  endif;

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// LESLIE-Steuerung
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  if TimeSlot = 4 then // freier Timeslot
    if edit_LesVolPotEna and LeslieVolumeADCchanged then // analoges Poti
      edit_LeslieVolume:= LeslieVolumeADC;
    {$IFDEF DEBUGTEST}
      write(serout, '# Leslie Volume change:');
      WriteByte(LeslieVolumeADC);
    {$ENDIF}
    endif;
    LeslieVolumeADCchanged:= false;
    if LeslieFast then
      my_dest_hornspeed:= edit_HornFastTm;
      my_dest_rotorspeed:= edit_RotorFastTm;
    else
      my_dest_hornspeed:= edit_HornSlowTm;
      my_dest_rotorspeed:= edit_RotorSlowTm;
    endif;
    MidiSendTab(68, LeslieRun);
    MidiSendTab(1, LeslieFast);

    if not LeslieRun then
      my_dest_hornspeed:= 0;
      my_dest_rotorspeed:= 0;
    endif;

    if isSystimerzero(HornTimer) then
      if LeslieHornSpeed <> my_dest_hornspeed then
        if my_dest_hornspeed > LeslieHornSpeed then
          inc(LeslieHornSpeed);
          setSysTimer(HornTimer,edit_HornRampUp);  // Anlauf
        else
          dec(LeslieHornSpeed);
          setSysTimer(HornTimer,edit_HornRampDown);  // Auslauf
        endif;
      endif;
    endif;

    if isSystimerzero(RotorTimer) then
      if LeslieRotorSpeed <> my_dest_rotorspeed then
        if my_dest_rotorspeed > LeslieRotorSpeed then
          inc(LeslieRotorSpeed);
          setSysTimer(RotorTimer,edit_RotorRampUp);  // Anlauf
        else
          dec(LeslieRotorSpeed);
          setSysTimer(RotorTimer,edit_RotorRampDown);  // Auslauf
        endif;
      endif;
    endif;

    speedblink:= speedblink + word(LeslieHornSpeed);

    SendByteToFPGA(LeslieHornSpeed, 177);
    SendByteToFPGA(LeslieRotorSpeed, 178);
    SendByteToFPGA(edit_LeslieVolume, 176);  // Volume-Poti 0..255!

    RelaisFast_Out := LeslieFast and LeslieRun;
    RelaisSlow_Out := (not LeslieFast) and LeslieRun;
    RelaisBassSw_Out := Tab_bassena;
    if TabSwitchPresent then
      TWIoutP($21,$03,@RelaisPort,1);    // 4 Bits Port PL12 setzen
    endif;
  endif;
  
  if TimeSlot = 5 then
    SendByteToFPGA(edit_LeslieThrob, 199);             // 2x Horn
    SendByteToFPGA(edit_LeslieThrob, 200);
    SendByteToFPGA((edit_LeslieThrob shr 1)+128, 203); // Rotor
    my_byte:= EE_Leslie_Init[48]+edit_LeslieSpread;
    SendByteToFPGA(my_byte, 225);
    my_byte:= EE_Leslie_Init[51]+edit_LeslieSpread;
    SendByteToFPGA(my_byte, 228);
    my_byte:= EE_Leslie_Init[53]+edit_LeslieSpread;
    SendByteToFPGA(my_byte, 230);
    my_byte:= EE_Leslie_Init[55]+edit_LeslieSpread;
    SendByteToFPGA(my_byte, 232);
  endif;
  
  if TimeSlot = 6 then
    // Rotor/Horn Balance einstellen - entgegengesetzten Wert absenken
    if edit_LeslieBalance >= 100 then // weniger Rotor-Anteil
      my_byte:= MulDivByte(EE_Leslie_Init[8],(200-edit_LeslieBalance), 100);
      SendByteToFPGA(my_byte, 184);   // skalierter Rotor-Anteil
      
      SendByteToFPGA(EE_Leslie_Init[4], 180);  // 4x Hornpegel konstant
      SendByteToFPGA(EE_Leslie_Init[5], 181);
      SendByteToFPGA(EE_Leslie_Init[6], 182);
      SendByteToFPGA(EE_Leslie_Init[12], 188);
    else                              // weniger Horn-Anteil
      my_byte:= MulDivByte(EE_Leslie_Init[4],edit_LeslieBalance, 100);
      SendByteToFPGA(my_byte, 180);   // skalierte Horn-Anteile
      my_byte:= MulDivByte(EE_Leslie_Init[5],edit_LeslieBalance, 100);
      SendByteToFPGA(my_byte, 181);
      my_byte:= MulDivByte(EE_Leslie_Init[6],edit_LeslieBalance, 100);
      SendByteToFPGA(my_byte, 182);
      my_byte:= MulDivByte(EE_Leslie_Init[12],edit_LeslieBalance, 100);
      SendByteToFPGA(my_byte, 188);
      
      SendByteToFPGA(EE_Leslie_Init[8], 184); // 1x Rotorpegel konstant
    endif;
  endif;
end;

// #############################################################################

procedure AllParamsToFPGA;
// Vorbereitete Parameter-Tabelle für HX3-Engine umrechnen
// und Daten an FPGA SPI senden

begin
  OrganInitToFPGA;
  LeslieInitToFPGA;
  ReverbToFPGA;
  UpperToFPGA;
  LowerToFPGA;
  BassSplitToFPGA;
  VibratoToFPGA;
  LeslieVolumeADCchanged:= false;
  ToneADCchanged:= true;
  VolumeToFPGA;
end;


// #############################################################################
// ###                       Report Hardware-Status                          ###
// #############################################################################

procedure PortCheck;
begin
  WriteChPrefix;
  write(serout, '0 [HW CHECK]');
  SerCRLF;
  if TabButtonsPresent then
    ParamLong:=1;
    CommentStr:= 'Button/LED Driver';
    WriteParamLongCommentSer;
    initPCA9532($62);
  endif;
  if UpperPresetsPresent then
    ParamLong:=2;
    CommentStr:= 'Upper Preset Panel';
    WriteParamLongCommentSer;
    initPCA9532($60);
  endif;
  if LowerPresetsPresent then
    ParamLong:=3;
    CommentStr:= 'Lower Preset Panel';
    WriteParamLongCommentSer;
    initPCA9532($61);
  endif;

  PCA9532LED:=0; // %01 = ON, %10 = DIM, %11 = BLINK

  if TabSwitchPresent then
    ParamLong:=4;
    CommentStr:= 'Switches Inp';
    WriteParamLongCommentSer;
  endif;

  if VibSwitchPresent then
    ParamLong:=5;
    CommentStr:= 'VibKnob Inp';
    WriteParamLongCommentSer;
  endif;
  if LCDPresent then
    ParamLong:=6;
    CommentStr:= 'LC Display';
    WriteParamLongCommentSer;
  endif;
  if Preset24present then
    ParamLong:=7;
    CommentStr:= 'Preset24 MPX';
    WriteParamLongCommentSer;
  endif;
  if MenuLEDsPresent then
    ParamLong:=8;
    CommentStr:= 'MenuPanel LEDs';
    WriteParamLongCommentSer;
  endif;
  if PreampCtrlPresent then
    ParamLong:=9;
    CommentStr:= 'Preamp Ctrl Out';
    WriteParamLongCommentSer;
  endif;
end;


// #############################################################################
// ###                          Weitere Funktionen                           ###
// #############################################################################

procedure InitReverb;
// Neuladen des FV-1 erzwingen durch kurze Umschaltung auf interne Programme
// u.a. von Parser gebraucht
begin
  memLED(true);
  mdelay(100); // Konfiguration FV-1 abwarten, bevor I2C benutzt wird
  SendByteToFPGA(0, 72); // EffektPort auf 0 = FV-1 intern
  mdelay(100); // Konfiguration FV-1 abwarten, bevor I2C benutzt wird
  ReverbToFPGA;
  memLED(false);
end;


